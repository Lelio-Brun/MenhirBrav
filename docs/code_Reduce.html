<html><head>
<link rel="stylesheet" href="doc.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Ast" rel="Chapter" href="Ast.html">
<link title="ExtendedAst" rel="Chapter" href="ExtendedAst.html">
<link title="Common" rel="Chapter" href="Common.html">
<link title="Scan" rel="Chapter" href="Scan.html">
<link title="Normalize" rel="Chapter" href="Normalize.html">
<link title="Transform" rel="Chapter" href="Transform.html">
<link title="Reduce" rel="Chapter" href="Reduce.html">
<link title="Printer" rel="Chapter" href="Printer.html">
<link title="GenericPrinter" rel="Chapter" href="GenericPrinter.html">
<link title="Helper" rel="Chapter" href="Helper.html">
<link title="MiniHelper" rel="Chapter" href="MiniHelper.html">
<link title="Default" rel="Chapter" href="Default.html">
<link title="MiniLatex" rel="Chapter" href="MiniLatex.html">
<link title="LatexTabular" rel="Chapter" href="LatexTabular.html">
<link title="LatexSyntax" rel="Chapter" href="LatexSyntax.html">
<link title="LatexBacknaur" rel="Chapter" href="LatexBacknaur.html">
<link title="Html" rel="Chapter" href="Html.html">
<link title="Printers" rel="Chapter" href="Printers.html">
<link title="Position" rel="Chapter" href="Position.html">
<link title="Main" rel="Chapter" href="Main.html"><title>Obelisk code documentation : Reduce</title>
</head>
<body>
<code class="code"></code><table><tr><td></td><td><span class="comment">(** Pattern-recognition and inlining.  *)</span></td></tr></table><code class="code"><br>
<br>
<span class="keyword">open</span>&nbsp;<span class="constructor">Lazy</span><br>
<span class="keyword">open</span>&nbsp;<span class="constructor">ExtendedAst</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** A map with identifiers keys. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">module</span>&nbsp;<span class="constructor">M</span>&nbsp;=&nbsp;<span class="constructor">Map</span>.<span class="constructor">Make</span>(<span class="constructor">String</span>)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <h2 id="2_Inlining">Inlining</h2>  *)</span></td></tr></table><code class="code"><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <h3 id="3_Instantiating">Instantiating</h3> *)</span></td></tr></table><code class="code"><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Performs a substitution over an actual.
    Only non functional symbols are substituted.  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;subst_actual&nbsp;s&nbsp;a&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;subst_pattern&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;subst_actual&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">function</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Option</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Option</span>&nbsp;(r&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pair</span>&nbsp;(x,&nbsp;y)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Pair</span>&nbsp;(r&nbsp;x,&nbsp;r&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepPair</span>&nbsp;(x,&nbsp;sep,&nbsp;y)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepPair</span>&nbsp;(r&nbsp;x,&nbsp;r&nbsp;sep,&nbsp;r&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Preceded</span>&nbsp;(o,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Preceded</span>&nbsp;(r&nbsp;o,&nbsp;r&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Terminated</span>&nbsp;(x,&nbsp;c)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Terminated</span>&nbsp;(r&nbsp;x,&nbsp;r&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Delimited</span>&nbsp;(o,&nbsp;x,&nbsp;c)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Delimited</span>&nbsp;(r&nbsp;o,&nbsp;r&nbsp;x,&nbsp;r&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">List</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">List</span>&nbsp;(r&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">NEList</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">NEList</span>&nbsp;(r&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepList</span>&nbsp;(sep,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepList</span>&nbsp;(r&nbsp;sep,&nbsp;r&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepNEList</span>&nbsp;(sep,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepNEList</span>&nbsp;(r&nbsp;sep,&nbsp;r&nbsp;x)<br>
&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;subst_production&nbsp;=&nbsp;<span class="constructor">List</span>.map&nbsp;(subst_actual&nbsp;s)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;a&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(f,&nbsp;[])&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">M</span>.find&nbsp;f&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;<span class="constructor">Not_found</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(f,&nbsp;[])<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(f,&nbsp;xs)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Symbol</span>&nbsp;(f,&nbsp;<span class="constructor">List</span>.map&nbsp;(subst_actual&nbsp;s)&nbsp;xs)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pattern</span>&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Pattern</span>&nbsp;(subst_pattern&nbsp;p)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Modifier</span>&nbsp;(x,&nbsp;m)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Modifier</span>&nbsp;(subst_actual&nbsp;s&nbsp;x,&nbsp;m)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Anonymous</span>&nbsp;ps&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Anonymous</span>&nbsp;(<span class="constructor">List</span>.map&nbsp;subst_production&nbsp;ps)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code">make_subst&nbsp;xs&nbsp;ys</code> builds a substitution that is a map linking each element
    of <code class="code">xs</code> to the corresponding (by index) element of <code class="code">ys</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;make_subst&nbsp;=<br>
&nbsp;&nbsp;<span class="constructor">List</span>.fold_left2&nbsp;(<span class="keyword">fun</span>&nbsp;s&nbsp;x&nbsp;y&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">M</span>.add&nbsp;x&nbsp;y&nbsp;s)&nbsp;<span class="constructor">M</span>.empty<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code">subst&nbsp;(xs,&nbsp;p)&nbsp;ys</code> substitutes the formal parameters <code class="code">xs</code> with the actual
    parameters <code class="code">ys</code> in the pattern <code class="code">p</code>.*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;subst&nbsp;(xs,&nbsp;p)&nbsp;ys&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;s&nbsp;=&nbsp;make_subst&nbsp;xs&nbsp;ys&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;=&nbsp;subst_actual&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;p&nbsp;=&nbsp;<span class="keyword">match</span>&nbsp;p&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Option</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Option</span>&nbsp;(f&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pair</span>&nbsp;(x,&nbsp;y)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Pair</span>&nbsp;(f&nbsp;x,&nbsp;f&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepPair</span>&nbsp;(x,&nbsp;sep,&nbsp;y)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepPair</span>&nbsp;(f&nbsp;x,&nbsp;f&nbsp;sep,&nbsp;f&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Preceded</span>&nbsp;(o,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Preceded</span>&nbsp;(f&nbsp;o,&nbsp;f&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Terminated</span>&nbsp;(x,&nbsp;c)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Terminated</span>&nbsp;(f&nbsp;x,&nbsp;f&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Delimited</span>&nbsp;(o,&nbsp;x,&nbsp;c)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Delimited</span>&nbsp;(f&nbsp;o,&nbsp;f&nbsp;x,&nbsp;f&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">List</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">List</span>&nbsp;(f&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">NEList</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">NEList</span>&nbsp;(f&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepList</span>&nbsp;(sep,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepList</span>&nbsp;(f&nbsp;sep,&nbsp;f&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepNEList</span>&nbsp;(sep,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepNEList</span>&nbsp;(f&nbsp;sep,&nbsp;f&nbsp;x)<br>
&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="constructor">Pattern</span>&nbsp;p<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <h3 id="3_Rewriting">Rewriting</h3>  *)</span></td></tr></table><code class="code"><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Inline the recognized patterns in an actual.
    If the actual is a symbol <code class="code">s</code>, then we look in the map if <code class="code">s</code> should be
    inlined. In this case, we use <code class="code">subst</code> to perform the inlining, that is to
    instantiate the recognized pattern obtained in the map with the actual
    parameters of <code class="code">s</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;rewrite_actual&nbsp;rws&nbsp;=&nbsp;<span class="keyword">function</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;xs&nbsp;=&nbsp;<span class="constructor">List</span>.map&nbsp;(rewrite_actual&nbsp;rws)&nbsp;xs&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rw&nbsp;=&nbsp;<span class="constructor">M</span>.find&nbsp;s&nbsp;rws&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subst&nbsp;rw&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;<span class="constructor">Not_found</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pattern</span>&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Pattern</span>&nbsp;(rewrite_pattern&nbsp;rws&nbsp;p)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Modifier</span>&nbsp;(x,&nbsp;m)&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Modifier</span>&nbsp;(rewrite_actual&nbsp;rws&nbsp;x,&nbsp;m)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Anonymous</span>&nbsp;ps&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Anonymous</span>&nbsp;(<span class="constructor">List</span>.map&nbsp;(rewrite_production&nbsp;rws)&nbsp;ps)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Inline the recognized patterns in a pattern. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">and</span>&nbsp;rewrite_pattern&nbsp;rws&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;r&nbsp;=&nbsp;rewrite_actual&nbsp;rws&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">function</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Option</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Option</span>&nbsp;(r&nbsp;x)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pair</span>&nbsp;(x,&nbsp;y)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Pair</span>&nbsp;(r&nbsp;x,&nbsp;r&nbsp;y)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepPair</span>&nbsp;(x,&nbsp;sep,&nbsp;y)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepPair</span>&nbsp;(r&nbsp;x,&nbsp;r&nbsp;sep,&nbsp;r&nbsp;y)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Preceded</span>&nbsp;(o,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Preceded</span>&nbsp;(r&nbsp;o,&nbsp;r&nbsp;x)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Terminated</span>&nbsp;(x,&nbsp;c)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Terminated</span>&nbsp;(r&nbsp;x,&nbsp;r&nbsp;c)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Delimited</span>&nbsp;(o,&nbsp;x,&nbsp;c)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">Delimited</span>&nbsp;(r&nbsp;o,&nbsp;r&nbsp;x,&nbsp;r&nbsp;c)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">List</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">List</span>&nbsp;(r&nbsp;x)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">NEList</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">NEList</span>&nbsp;(r&nbsp;x)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepList</span>&nbsp;(sep,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepList</span>&nbsp;(r&nbsp;sep,&nbsp;r&nbsp;x)<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepNEList</span>&nbsp;(sep,&nbsp;x)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">SepNEList</span>&nbsp;(r&nbsp;sep,&nbsp;r&nbsp;x)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Inline the recognized patterns in a production. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">and</span>&nbsp;rewrite_production&nbsp;rws&nbsp;=<br>
&nbsp;&nbsp;<span class="constructor">List</span>.map&nbsp;(rewrite_actual&nbsp;rws)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Inline the recognized patterns in a rule. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;rewrite_rule&nbsp;rws&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;prods&nbsp;=&nbsp;<span class="constructor">List</span>.map&nbsp;(rewrite_production&nbsp;rws)&nbsp;r.prods&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;{&nbsp;r&nbsp;<span class="keyword">with</span>&nbsp;prods&nbsp;}<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Inline the recognized patterns in the grammar. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;rewrite&nbsp;rws&nbsp;=<br>
&nbsp;&nbsp;<span class="constructor">List</span>.map&nbsp;(rewrite_rule&nbsp;rws)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <h2 id="2_Reducing">Reducing</h2>  *)</span></td></tr></table><code class="code"><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <h3 id="3_Patternrecognition">Pattern recognition</h3>  *)</span></td></tr></table><code class="code"><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** A lazy "monadic" composition operator for the <code class="code">option</code> monad.
    <code class="code">compose&nbsp;x&nbsp;y</code> returns <code class="code">y</code> if <code class="code">x</code> fails otherwise it returns <code class="code">x</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;compose&nbsp;x&nbsp;y&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;force&nbsp;x&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">None</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;y<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;x<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** An infix notation for <code class="code">compose</code>.  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;(@@)&nbsp;=&nbsp;compose<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Find a rule by its left-hand side (name) in the grammar. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;find_rule&nbsp;r&nbsp;rules&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">try</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Some</span>&nbsp;(<span class="constructor">List</span>.find&nbsp;(<span class="keyword">fun</span>&nbsp;{name}&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;name&nbsp;=&nbsp;r)&nbsp;rules)<br>
&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;<span class="constructor">Not_found</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Define a recursive equivalence between rules by
    transitivity.
<p>

    <code class="code">alias&nbsp;rules&nbsp;r&nbsp;r'</code> is <code class="code"><span class="keyword">true</span></code> if <code class="code">r&nbsp;=&nbsp;r'</code> or if the rule of name <code class="code">r'</code> in
    <code class="code">rules</code> is made of a unique production consisting of a unique symbol
    recursively equivalent to <code class="code">r</code>.  *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;alias&nbsp;rules&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;eq&nbsp;r'&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;r'&nbsp;<span class="keywordsign">||</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;find_rule&nbsp;r'&nbsp;rules&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Some</span>&nbsp;{&nbsp;prods&nbsp;=&nbsp;[[<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;_)]]&nbsp;}&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;eq&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">false</span><br>
&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;eq<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Define an equivalence between formal and actual parameters. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;equal_params&nbsp;=&nbsp;<span class="constructor">List</span>.for_all2&nbsp;(<span class="keyword">fun</span>&nbsp;x&nbsp;y&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;y&nbsp;=&nbsp;<span class="constructor">Symbol</span>&nbsp;(x,&nbsp;[]))<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code">not_occurs&nbsp;s&nbsp;a</code> is <code class="code"><span class="keyword">true</span></code> when the symbol <code class="code">s</code> does not occur in
    the actual <code class="code">a</code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;not_occurs&nbsp;s&nbsp;a&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;not_occurs_pattern&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;n&nbsp;=&nbsp;not_occurs&nbsp;s&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">function</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Option</span>&nbsp;x&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">List</span>&nbsp;x&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">NEList</span>&nbsp;x&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;n&nbsp;x<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pair</span>&nbsp;(x,&nbsp;y)&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Preceded</span>&nbsp;(x,&nbsp;y)&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Terminated</span>&nbsp;(x,&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepList</span>&nbsp;(x,&nbsp;y)&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepNEList</span>&nbsp;(x,&nbsp;y)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;n&nbsp;x&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;n&nbsp;y<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">SepPair</span>&nbsp;(x,&nbsp;y,&nbsp;z)&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Delimited</span>&nbsp;(x,&nbsp;y,&nbsp;z)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;n&nbsp;x&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;n&nbsp;y&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;n&nbsp;z<br>
&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;a&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(f,&nbsp;xs)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;f&nbsp;&lt;&gt;&nbsp;s&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s)&nbsp;xs<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pattern</span>&nbsp;p&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;not_occurs_pattern&nbsp;p<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Modifier</span>&nbsp;(x,&nbsp;_)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;not_occurs&nbsp;s&nbsp;x<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Anonymous</span>&nbsp;ps&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s))&nbsp;ps<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Merely wrap the arguments under a <code class="code"><span class="constructor">Some</span></code>. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;generalize&nbsp;xs&nbsp;p&nbsp;=&nbsp;<span class="constructor">Some</span>&nbsp;(xs,&nbsp;p)<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Decide if the rule is a list, that is if it has the following shape:
    <pre class="verbatim">l(xs) ::=           or    l(xs) ::=
        | eps                     | `cons`
        | `cons`                  | eps</pre>
    where<ul>
<li><code class="code"><span class="keywordsign">`</span>cons<span class="keywordsign">`</span>&nbsp;=&nbsp;s(ys)&nbsp;::&nbsp;acts</code></li>
<li><code class="code">s</code> and <code class="code">l</code> are equivalent according to <code class="code">alias</code></li>
<li><code class="code">xs</code> and <code class="code">ys</code> are equivalent according to <code class="code">equal_params</code></li>
<li><code class="code">s</code> does <code class="code">not_occurs</code> in <code class="code">acts</code> </li>
</ul>
*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;is_list&nbsp;rules&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;generalize&nbsp;r.params&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;r.prods&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[[];&nbsp;cons]&nbsp;<span class="keywordsign">|</span>&nbsp;[cons;&nbsp;[]]&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">match</span>&nbsp;cons&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)&nbsp;::&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">when</span>&nbsp;alias&nbsp;rules&nbsp;r.name&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;equal_params&nbsp;r.params&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s)&nbsp;acts&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;(<span class="constructor">List</span>&nbsp;(<span class="constructor">Anonymous</span>&nbsp;[acts]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">match</span>&nbsp;<span class="constructor">List</span>.rev&nbsp;cons&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)&nbsp;::&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">when</span>&nbsp;alias&nbsp;rules&nbsp;r.name&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;equal_params&nbsp;r.params&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s)&nbsp;acts&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;(<span class="constructor">List</span>&nbsp;(<span class="constructor">Anonymous</span>&nbsp;[<span class="constructor">List</span>.rev&nbsp;acts]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Decide if the rule is a separated non empty list,
    that is if it has the following shape:
    <pre class="verbatim">nel(xs) ::=           or    nel(xs) ::=
          | `base`                    | `cons`
          | `cons`                    | `base`</pre>
    where<ul>
<li><code class="code"><span class="keywordsign">`</span>cons<span class="keywordsign">`</span>&nbsp;=&nbsp;s(ys)&nbsp;::&nbsp;acts</code></li>
<li><code class="code">s</code> and <code class="code">nel</code> are equivalent according to <code class="code">alias</code></li>
<li><code class="code">xs</code> and <code class="code">ys</code> are equivalent according to <code class="code">equal_params</code></li>
<li><code class="code">s</code> does <code class="code">not_occurs</code> in <code class="code">acts</code></li>
<li><code class="code">acts&nbsp;=&nbsp;<span class="keywordsign">`</span>base<span class="keywordsign">`</span></code></li>
</ul>

    This condition is explained for a left-recursive list but the function
    also copes with right-recursion. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;is_nonempty_list&nbsp;rules&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;generalize&nbsp;r.params&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;base&nbsp;cons&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;cons&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)&nbsp;::&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">when</span>&nbsp;alias&nbsp;rules&nbsp;r.name&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;equal_params&nbsp;r.params&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s)&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;base&nbsp;=&nbsp;acts&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;(<span class="constructor">NEList</span>&nbsp;(<span class="constructor">Anonymous</span>&nbsp;[acts]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">match</span>&nbsp;<span class="constructor">List</span>.rev&nbsp;cons&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)&nbsp;::&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">when</span>&nbsp;alias&nbsp;rules&nbsp;r.name&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;equal_params&nbsp;r.params&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s)&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;base&nbsp;=&nbsp;acts&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;(<span class="constructor">NEList</span>&nbsp;(<span class="constructor">Anonymous</span>&nbsp;[<span class="constructor">List</span>.rev&nbsp;acts]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;r.prods&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[x;&nbsp;y]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">lazy</span>&nbsp;(f&nbsp;x&nbsp;y)&nbsp;@@&nbsp;<span class="keyword">lazy</span>&nbsp;(f&nbsp;y&nbsp;x)&nbsp;|&gt;&nbsp;force<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Decide if the rule is a separated non empty list,
    that is if it has the following shape:
    <pre class="verbatim">snel(xs) ::=           or    snel(xs) ::=
           | `base`                     | `cons`
           | `cons`                     | `base`</pre>
    where<ul>
<li><code class="code"><span class="keywordsign">`</span>cons<span class="keywordsign">`</span>&nbsp;=&nbsp;s(ys)&nbsp;::&nbsp;acts</code></li>
<li><code class="code">s</code> and <code class="code">snel</code> are equivalent according to <code class="code">alias</code></li>
<li><code class="code">xs</code> and <code class="code">ys</code> are equivalent according to <code class="code">equal_params</code></li>
<li><code class="code">s</code> does <code class="code">not_occurs</code> in <code class="code">acts</code></li>
<li><code class="code">acts&nbsp;=&nbsp;sep&nbsp;@&nbsp;<span class="keywordsign">`</span>base<span class="keywordsign">`</span></code></li>
</ul>

    This condition is explained for a left-recursive list but the function
    also copes with right-recursion. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;is_sep_nonempty_list&nbsp;rules&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;take&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;aux&nbsp;pre&nbsp;n&nbsp;xs&nbsp;=&nbsp;<span class="keyword">match</span>&nbsp;n,&nbsp;xs&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;0,&nbsp;xs&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">List</span>.rev&nbsp;pre,&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_,&nbsp;[]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">List</span>.rev&nbsp;pre,&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;n,&nbsp;x::xs&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;aux&nbsp;(x&nbsp;::&nbsp;pre)&nbsp;(n-1)&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;aux&nbsp;[]<br>
&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;generalize&nbsp;r.params&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;f&nbsp;base&nbsp;cons&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;cons&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)&nbsp;::&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">when</span>&nbsp;alias&nbsp;rules&nbsp;r.name&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;equal_params&nbsp;r.params&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s)&nbsp;acts&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;base_r,&nbsp;sep_r&nbsp;=&nbsp;take&nbsp;(<span class="constructor">List</span>.length&nbsp;base)&nbsp;(<span class="constructor">List</span>.rev&nbsp;acts)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;base&nbsp;=&nbsp;<span class="constructor">List</span>.rev&nbsp;base_r<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;(<span class="constructor">SepNEList</span>&nbsp;(<span class="constructor">Anonymous</span>&nbsp;[<span class="constructor">List</span>.rev&nbsp;sep_r],&nbsp;<span class="constructor">Anonymous</span>&nbsp;[base]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">match</span>&nbsp;<span class="constructor">List</span>.rev&nbsp;cons&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)&nbsp;::&nbsp;acts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">when</span>&nbsp;alias&nbsp;rules&nbsp;r.name&nbsp;s<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;equal_params&nbsp;r.params&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">&amp;&amp;</span>&nbsp;<span class="constructor">List</span>.for_all&nbsp;(not_occurs&nbsp;s)&nbsp;acts&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;base',&nbsp;sep&nbsp;=&nbsp;take&nbsp;(<span class="constructor">List</span>.length&nbsp;base)&nbsp;(<span class="constructor">List</span>.rev&nbsp;acts)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;base&nbsp;=&nbsp;base'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">then</span>&nbsp;g&nbsp;(<span class="constructor">SepNEList</span>&nbsp;(<span class="constructor">Anonymous</span>&nbsp;[sep],&nbsp;<span class="constructor">Anonymous</span>&nbsp;[base]))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;r.prods&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[x;&nbsp;y]&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="keyword">lazy</span>&nbsp;(f&nbsp;x&nbsp;y)&nbsp;@@&nbsp;<span class="keyword">lazy</span>&nbsp;(f&nbsp;y&nbsp;x)&nbsp;|&gt;&nbsp;force<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Decide if the rule is a separated list,
    that is if it has the following shape:
    <pre class="verbatim">sl ::=              or    sl ::=
     | eps                     | snel(...)
     | snel(...)               | eps</pre>
    where <code class="code">snel</code> is recognized as a <code class="code">separated_nonempty_list</code> by
    <code class="code">is_sep_nonempty_list</code>.
*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;is_sep_list&nbsp;rules&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;g&nbsp;=&nbsp;generalize&nbsp;r.params&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;r.prods&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[[];&nbsp;[<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)]]&nbsp;<span class="keywordsign">|</span>&nbsp;[[<span class="constructor">Symbol</span>&nbsp;(s,&nbsp;xs)];&nbsp;[]]&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">match</span>&nbsp;find_rule&nbsp;s&nbsp;rules&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Some</span>&nbsp;r'&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">match</span>&nbsp;is_sep_nonempty_list&nbsp;rules&nbsp;r'&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Some</span>&nbsp;rw&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">begin</span>&nbsp;<span class="keyword">match</span>&nbsp;subst&nbsp;rw&nbsp;xs&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Pattern</span>&nbsp;(<span class="constructor">SepNEList</span>&nbsp;(sep,&nbsp;x))&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;g&nbsp;(<span class="constructor">SepList</span>&nbsp;(sep,&nbsp;x))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">None</span>&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">end</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Decide if the rule is an optional, that is if it has the following shape:
    <pre class="verbatim">r ::=       or    r ::=
   | eps              | `some`
   | `some`           | eps</pre>
*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;is_option&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;r.prods&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;[[];&nbsp;some]&nbsp;<span class="keywordsign">|</span>&nbsp;[some;&nbsp;[]]&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;some&nbsp;=&nbsp;[]&nbsp;<span class="keyword">then</span>&nbsp;<span class="constructor">None</span>&nbsp;<span class="keyword">else</span>&nbsp;generalize&nbsp;r.params&nbsp;(<span class="constructor">Option</span>&nbsp;(<span class="constructor">Anonymous</span>&nbsp;[some]))<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;_&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;<span class="constructor">None</span><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Decide if the rule is a standard pattern. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;recognize&nbsp;rules&nbsp;r&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">lazy</span>&nbsp;(is_list&nbsp;rules&nbsp;r)<br>
&nbsp;&nbsp;@@&nbsp;<span class="keyword">lazy</span>&nbsp;(is_nonempty_list&nbsp;rules&nbsp;r)<br>
&nbsp;&nbsp;@@&nbsp;<span class="keyword">lazy</span>&nbsp;(is_sep_nonempty_list&nbsp;rules&nbsp;r)<br>
&nbsp;&nbsp;@@&nbsp;<span class="keyword">lazy</span>&nbsp;(is_sep_list&nbsp;rules&nbsp;r)<br>
&nbsp;&nbsp;@@&nbsp;<span class="keyword">lazy</span>&nbsp;(is_option&nbsp;r)<br>
&nbsp;&nbsp;|&gt;&nbsp;force<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <h3 id="3_Rulereducing">Rule reducing</h3>  *)</span></td></tr></table><code class="code"><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** Replace the right-hand side of a rule with the given pattern. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;replace_prods&nbsp;r&nbsp;(_,&nbsp;p)&nbsp;=<br>
&nbsp;&nbsp;{&nbsp;r&nbsp;<span class="keyword">with</span>&nbsp;prods&nbsp;=&nbsp;[[<span class="constructor">Pattern</span>&nbsp;p]]&nbsp;}<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code">reduce_rule&nbsp;inline&nbsp;rules&nbsp;r&nbsp;(rs,&nbsp;rws)</code> returns a pair of a list of "reduced"
    rules and a map from identifiers to a pair of a list of parameters and
    a pattern, that is a map of recognized patterns.
<p>

    If the rule <code class="code">r</code> is recognized as a standard pattern then<ul>
<li>if <code class="code">inline</code> is <code class="code"><span class="keyword">true</span></code>: <code class="code">r</code> is skipped and added to the map of recognized
      patterns along with the according recognized pattern.</li>
<li>if <code class="code">inline</code> is <code class="code"><span class="keyword">false</span></code>: the right-hand side of <code class="code">r</code> is replaced by the
      recognized pattern. </li>
</ul>
*)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;reduce_rule&nbsp;inline&nbsp;rules&nbsp;r&nbsp;(rs,&nbsp;rws)&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">match</span>&nbsp;recognize&nbsp;rules&nbsp;r&nbsp;<span class="keyword">with</span><br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">Some</span>&nbsp;rw&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;inline&nbsp;<span class="keyword">then</span>&nbsp;(rs,&nbsp;<span class="constructor">M</span>.add&nbsp;r.name&nbsp;rw&nbsp;rws)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;replace_prods&nbsp;r&nbsp;rw&nbsp;::&nbsp;rs,&nbsp;rws<br>
&nbsp;&nbsp;<span class="keywordsign">|</span>&nbsp;<span class="constructor">None</span>&nbsp;<span class="keywordsign">-&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;::&nbsp;rs,&nbsp;rws<br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <h2 id="2_Alltogether">All together</h2> *)</span></td></tr></table><code class="code"><br>
<br>
</code><table><tr><td></td><td><span class="comment">(** <code class="code">reduce&nbsp;inline&nbsp;s</code> returns the grammar <code class="code">s</code> in which the right-hand sides
    recognized as standard patterns are replaced by an instance of this pattern
    (list, optional, ...).
<p>

    Moreover, if <code class="code">inline</code> is <code class="code"><span class="keyword">true</span></code> then the concerned
    rules are deleted and inlined at each of their instances. *)</span></td></tr></table><code class="code"><br>
<span class="keyword">let</span>&nbsp;reduce&nbsp;inline&nbsp;s&nbsp;=<br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;rules,&nbsp;rws&nbsp;=&nbsp;<span class="constructor">List</span>.fold_right&nbsp;(reduce_rule&nbsp;inline&nbsp;s)&nbsp;s&nbsp;([],&nbsp;<span class="constructor">M</span>.empty)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;inline&nbsp;<span class="keyword">then</span>&nbsp;rewrite&nbsp;rws&nbsp;rules&nbsp;<span class="keyword">else</span>&nbsp;rules<br>
</code></body></html>