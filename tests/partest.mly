/* This ocamlyacc file was machine-generated by the BNF converter */
/* This file was supplied by Andreas Abel, see Menhir issue #31.  */
%{
open Abstest
open Lexing


%}

%token TOK_EOF
%token TOK_abstract TOK_and TOK_and_eq TOK_as TOK_asm TOK_asr TOK_assert TOK_auto TOK_begin TOK_bitand TOK_bitor TOK_bool TOK_boolean TOK_break TOK_byte TOK_case TOK_catch TOK_char TOK_class TOK_compl TOK_const TOK_const_cast TOK_constraint TOK_continue TOK_data TOK_default TOK_delete TOK_deriving TOK_do TOK_done TOK_double TOK_downto TOK_dynamic_cast TOK_else TOK_end TOK_enum TOK_exception TOK_explicit TOK_extends TOK_extern TOK_external TOK_false TOK_family TOK_final TOK_finally TOK_float TOK_for TOK_forall TOK_foreign TOK_friend TOK_fun TOK_function TOK_functor TOK_goto TOK_hiding TOK_if TOK_implements TOK_import TOK_in TOK_include TOK_infix TOK_infixl TOK_infixr TOK_inherit TOK_initializer TOK_inline TOK_instance TOK_instanceof TOK_int TOK_interface TOK_land TOK_lazy TOK_let TOK_list TOK_long TOK_lor TOK_lsl TOK_lsr TOK_lxor TOK_match TOK_mdo TOK_method TOK_mod TOK_module TOK_mutable TOK_namespace TOK_native TOK_new TOK_newtype TOK_nonrec TOK_not TOK_not_eq TOK_null TOK_object TOK_of TOK_open TOK_operator TOK_or TOK_or_eq TOK_package TOK_pattern TOK_private TOK_proc TOK_protected TOK_public TOK_qualified TOK_rec TOK_register TOK_reinterpret_cast TOK_return TOK_short TOK_sig TOK_signed TOK_sizeof TOK_static_cast TOK_strictfp TOK_string TOK_struct TOK_super TOK_switch TOK_synchronized TOK_template TOK_then TOK_this TOK_throw TOK_throws TOK_to TOK_transient TOK_true TOK_try TOK_type TOK_typedef TOK_typeid TOK_typename TOK_union TOK_unsigned TOK_using TOK_val TOK_virtual TOK_void TOK_volatile TOK_wchar_t TOK_when TOK_where TOK_while TOK_with TOK_xor TOK_xor_eq



%start pProgram pAbstract pAndT pAndEq pAnd_Eq pAsT pAsm pAsrT pAssertT pAuto pBeginT pBitand pBitor pBool pBoolean pBreak pByte pCase pCatch pChar_ pClassT pCompl pConst pConstCast pConst_Cast pConstraintT pContinue pData pDefault pDelete pDeriving pDoT pDoneT pDouble_ pDowntoT pDynamicCast pDynamic_Cast pElseT pEndT pEnum pExceptionT pExplicit pExtends pExtern pExternalT pFalseT pFamily pFinal pFinally pFloat pForT pForall pForeign pFriend pFunT pFunctionT pFunctorT pGoto pHiding pIfT pImplements pImport pInT pIncludeT pInfix pInfixl pInfixr pInheritT pInitializerT pInline pInstance pInstanceof pInt pInterface pLandT pLazyT pLetT pListT pLong pLorT pLslT pLsrT pLxorT pMatchT pMdo pMethodT pModT pModuleT pMutableT pNamespace pNative pNewT pNewtype pNonrecT pNot pNotEq pNot_Eq pNull pObjectT pOfT pOpenT pOperator pOrT pOrEq pOr_Eq pPackage pPattern pPrivateT pProc pProtected pPublic pQualified pRecT pRegister pReinterpretCast pReinterpret_Cast pReturn pShort pSigT pSigned pSizeof pStaticCast pStatic_Cast pStrictfp pString_ pStructT pSuper pSwitch pSynchronized pTemplate pThenT pThis pThrow pThrows pToT pTransient pTrueT pTryT pTypeT pTypedef pTypeid pTypename pUnion pUnsigned pUsing pValT pVirtualT pVoid pVolatile pWcharT pWchar_T pWhenT pWhere pWhileT pWithT pXor pXorEq pXor_Eq
%type <Abstest.program> pProgram
%type <Abstest.abstract> pAbstract
%type <Abstest.andT> pAndT
%type <Abstest.andEq> pAndEq
%type <Abstest.and_Eq> pAnd_Eq
%type <Abstest.asT> pAsT
%type <Abstest.asm> pAsm
%type <Abstest.asrT> pAsrT
%type <Abstest.assertT> pAssertT
%type <Abstest.auto> pAuto
%type <Abstest.beginT> pBeginT
%type <Abstest.bitand> pBitand
%type <Abstest.bitor> pBitor
%type <Abstest.bool> pBool
%type <Abstest.boolean> pBoolean
%type <Abstest.break> pBreak
%type <Abstest.byte> pByte
%type <Abstest.case> pCase
%type <Abstest.catch> pCatch
%type <Abstest.char_> pChar_
%type <Abstest.classT> pClassT
%type <Abstest.compl> pCompl
%type <Abstest.const> pConst
%type <Abstest.constCast> pConstCast
%type <Abstest.const_Cast> pConst_Cast
%type <Abstest.constraintT> pConstraintT
%type <Abstest.continue> pContinue
%type <Abstest.data> pData
%type <Abstest.default> pDefault
%type <Abstest.delete> pDelete
%type <Abstest.deriving> pDeriving
%type <Abstest.doT> pDoT
%type <Abstest.doneT> pDoneT
%type <Abstest.double_> pDouble_
%type <Abstest.downtoT> pDowntoT
%type <Abstest.dynamicCast> pDynamicCast
%type <Abstest.dynamic_Cast> pDynamic_Cast
%type <Abstest.elseT> pElseT
%type <Abstest.endT> pEndT
%type <Abstest.enum> pEnum
%type <Abstest.exceptionT> pExceptionT
%type <Abstest.explicit> pExplicit
%type <Abstest.extends> pExtends
%type <Abstest.extern> pExtern
%type <Abstest.externalT> pExternalT
%type <Abstest.falseT> pFalseT
%type <Abstest.family> pFamily
%type <Abstest.final> pFinal
%type <Abstest.finally> pFinally
%type <Abstest.float> pFloat
%type <Abstest.forT> pForT
%type <Abstest.forall> pForall
%type <Abstest.foreign> pForeign
%type <Abstest.friend> pFriend
%type <Abstest.funT> pFunT
%type <Abstest.functionT> pFunctionT
%type <Abstest.functorT> pFunctorT
%type <Abstest.goto> pGoto
%type <Abstest.hiding> pHiding
%type <Abstest.ifT> pIfT
%type <Abstest.implements> pImplements
%type <Abstest.import> pImport
%type <Abstest.inT> pInT
%type <Abstest.includeT> pIncludeT
%type <Abstest.infix> pInfix
%type <Abstest.infixl> pInfixl
%type <Abstest.infixr> pInfixr
%type <Abstest.inheritT> pInheritT
%type <Abstest.initializerT> pInitializerT
%type <Abstest.inline> pInline
%type <Abstest.instance> pInstance
%type <Abstest.instanceof> pInstanceof
%type <Abstest.int> pInt
%type <Abstest.interface> pInterface
%type <Abstest.landT> pLandT
%type <Abstest.lazyT> pLazyT
%type <Abstest.letT> pLetT
%type <Abstest.listT> pListT
%type <Abstest.long> pLong
%type <Abstest.lorT> pLorT
%type <Abstest.lslT> pLslT
%type <Abstest.lsrT> pLsrT
%type <Abstest.lxorT> pLxorT
%type <Abstest.matchT> pMatchT
%type <Abstest.mdo> pMdo
%type <Abstest.methodT> pMethodT
%type <Abstest.modT> pModT
%type <Abstest.moduleT> pModuleT
%type <Abstest.mutableT> pMutableT
%type <Abstest.namespace> pNamespace
%type <Abstest.native> pNative
%type <Abstest.newT> pNewT
%type <Abstest.newtype> pNewtype
%type <Abstest.nonrecT> pNonrecT
%type <Abstest.not> pNot
%type <Abstest.notEq> pNotEq
%type <Abstest.not_Eq> pNot_Eq
%type <Abstest.null> pNull
%type <Abstest.objectT> pObjectT
%type <Abstest.ofT> pOfT
%type <Abstest.openT> pOpenT
%type <Abstest.operator> pOperator
%type <Abstest.orT> pOrT
%type <Abstest.orEq> pOrEq
%type <Abstest.or_Eq> pOr_Eq
%type <Abstest.package> pPackage
%type <Abstest.pattern> pPattern
%type <Abstest.privateT> pPrivateT
%type <Abstest.proc> pProc
%type <Abstest.protected> pProtected
%type <Abstest.public> pPublic
%type <Abstest.qualified> pQualified
%type <Abstest.recT> pRecT
%type <Abstest.register> pRegister
%type <Abstest.reinterpretCast> pReinterpretCast
%type <Abstest.reinterpret_Cast> pReinterpret_Cast
%type <Abstest.return> pReturn
%type <Abstest.short> pShort
%type <Abstest.sigT> pSigT
%type <Abstest.signed> pSigned
%type <Abstest.sizeof> pSizeof
%type <Abstest.staticCast> pStaticCast
%type <Abstest.static_Cast> pStatic_Cast
%type <Abstest.strictfp> pStrictfp
%type <Abstest.string_> pString_
%type <Abstest.structT> pStructT
%type <Abstest.super> pSuper
%type <Abstest.switch> pSwitch
%type <Abstest.synchronized> pSynchronized
%type <Abstest.template> pTemplate
%type <Abstest.thenT> pThenT
%type <Abstest.this> pThis
%type <Abstest.throw> pThrow
%type <Abstest.throws> pThrows
%type <Abstest.toT> pToT
%type <Abstest.transient> pTransient
%type <Abstest.trueT> pTrueT
%type <Abstest.tryT> pTryT
%type <Abstest.typeT> pTypeT
%type <Abstest.typedef> pTypedef
%type <Abstest.typeid> pTypeid
%type <Abstest.typename> pTypename
%type <Abstest.union> pUnion
%type <Abstest.unsigned> pUnsigned
%type <Abstest.using> pUsing
%type <Abstest.valT> pValT
%type <Abstest.virtualT> pVirtualT
%type <Abstest.void> pVoid
%type <Abstest.volatile> pVolatile
%type <Abstest.wcharT> pWcharT
%type <Abstest.wchar_T> pWchar_T
%type <Abstest.whenT> pWhenT
%type <Abstest.where> pWhere
%type <Abstest.whileT> pWhileT
%type <Abstest.withT> pWithT
%type <Abstest.xor> pXor
%type <Abstest.xorEq> pXorEq
%type <Abstest.xor_Eq> pXor_Eq


%%
pProgram : program TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAbstract : abstract TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAndT : andT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAndEq : andEq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAnd_Eq : and_Eq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAsT : asT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAsm : asm TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAsrT : asrT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAssertT : assertT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pAuto : auto TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pBeginT : beginT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pBitand : bitand TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pBitor : bitor TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pBool : bool TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pBoolean : boolean TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pBreak : break TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pByte : byte TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pCase : case TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pCatch : catch TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pChar_ : char_ TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pClassT : classT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pCompl : compl TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pConst : const TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pConstCast : constCast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pConst_Cast : const_Cast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pConstraintT : constraintT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pContinue : continue TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pData : data TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDefault : default TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDelete : delete TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDeriving : deriving TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDoT : doT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDoneT : doneT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDouble_ : double_ TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDowntoT : downtoT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDynamicCast : dynamicCast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pDynamic_Cast : dynamic_Cast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pElseT : elseT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pEndT : endT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pEnum : enum TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pExceptionT : exceptionT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pExplicit : explicit TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pExtends : extends TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pExtern : extern TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pExternalT : externalT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFalseT : falseT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFamily : family TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFinal : final TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFinally : finally TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFloat : float TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pForT : forT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pForall : forall TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pForeign : foreign TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFriend : friend TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFunT : funT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFunctionT : functionT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pFunctorT : functorT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pGoto : goto TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pHiding : hiding TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pIfT : ifT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pImplements : implements TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pImport : import TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInT : inT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pIncludeT : includeT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInfix : infix TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInfixl : infixl TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInfixr : infixr TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInheritT : inheritT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInitializerT : initializerT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInline : inline TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInstance : instance TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInstanceof : instanceof TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInt : int TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pInterface : interface TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLandT : landT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLazyT : lazyT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLetT : letT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pListT : listT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLong : long TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLorT : lorT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLslT : lslT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLsrT : lsrT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pLxorT : lxorT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pMatchT : matchT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pMdo : mdo TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pMethodT : methodT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pModT : modT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pModuleT : moduleT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pMutableT : mutableT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNamespace : namespace TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNative : native TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNewT : newT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNewtype : newtype TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNonrecT : nonrecT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNot : not TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNotEq : notEq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNot_Eq : not_Eq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pNull : null TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pObjectT : objectT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pOfT : ofT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pOpenT : openT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pOperator : operator TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pOrT : orT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pOrEq : orEq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pOr_Eq : or_Eq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pPackage : package TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pPattern : pattern TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pPrivateT : privateT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pProc : proc TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pProtected : protected TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pPublic : public TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pQualified : qualified TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pRecT : recT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pRegister : register TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pReinterpretCast : reinterpretCast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pReinterpret_Cast : reinterpret_Cast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pReturn : return TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pShort : short TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pSigT : sigT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pSigned : signed TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pSizeof : sizeof TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pStaticCast : staticCast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pStatic_Cast : static_Cast TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pStrictfp : strictfp TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pString_ : string_ TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pStructT : structT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pSuper : super TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pSwitch : switch TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pSynchronized : synchronized TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTemplate : template TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pThenT : thenT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pThis : this TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pThrow : throw TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pThrows : throws TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pToT : toT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTransient : transient TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTrueT : trueT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTryT : tryT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTypeT : typeT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTypedef : typedef TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTypeid : typeid TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pTypename : typename TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pUnion : union TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pUnsigned : unsigned TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pUsing : using TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pValT : valT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pVirtualT : virtualT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pVoid : void TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pVolatile : volatile TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pWcharT : wcharT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pWchar_T : wchar_T TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pWhenT : whenT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pWhere : where TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pWhileT : whileT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pWithT : withT TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pXor : xor TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pXorEq : xorEq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };

pXor_Eq : xor_Eq TOK_EOF { $1 }
  | error { raise (BNFC_Util.Parse_error (Parsing.symbol_start_pos (), Parsing.symbol_end_pos ())) };


program : abstract andT andEq and_Eq asT asm asrT assertT auto beginT bitand bitor bool boolean break byte case catch char_ classT compl const constCast const_Cast constraintT continue data default delete deriving doT doneT double_ downtoT dynamicCast dynamic_Cast elseT endT enum exceptionT explicit extends extern externalT falseT family final finally float forT forall foreign friend funT functionT functorT goto hiding ifT implements import inT includeT infix infixl infixr inheritT initializerT inline instance instanceof int interface landT lazyT letT listT long lorT lslT lsrT lxorT matchT mdo methodT modT moduleT mutableT namespace native newT newtype nonrecT not notEq not_Eq null objectT ofT openT operator orT orEq or_Eq package pattern privateT proc protected public qualified recT register reinterpretCast reinterpret_Cast return short sigT signed sizeof staticCast static_Cast strictfp string_ structT super switch synchronized template thenT this throw throws toT transient trueT tryT typeT typedef typeid typename union unsigned using valT virtualT void volatile wcharT wchar_T whenT where whileT withT xor xorEq xor_Eq { Prg ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $80, $81, $82, $83, $84, $85, $86, $87, $88, $89, $90, $91, $92, $93, $94, $95, $96, $97, $98, $99, $100, $101, $102, $103, $104, $105, $106, $107, $108, $109, $110, $111, $112, $113, $114, $115, $116, $117, $118, $119, $120, $121, $122, $123, $124, $125, $126, $127, $128, $129, $130, $131, $132, $133, $134, $135, $136, $137, $138, $139, $140, $141, $142, $143, $144, $145, $146, $147, $148, $149, $150, $151, $152, $153, $154, $155, $156, $157) }
;

abstract : TOK_abstract { Abstract_Mk  }
;

andT : TOK_and { And_Mk  }
;

andEq : TOK_and_eq { AndEq_Mk  }
;

and_Eq : TOK_and_eq { And_Eq_Mk  }
;

asT : TOK_as { As_Mk  }
;

asm : TOK_asm { Asm_Mk  }
;

asrT : TOK_asr { Asr_Mk  }
;

assertT : TOK_assert { Assert_Mk  }
;

auto : TOK_auto { Auto_Mk  }
;

beginT : TOK_begin { Begin_Mk  }
;

bitand : TOK_bitand { Bitand_Mk  }
;

bitor : TOK_bitor { Bitor_Mk  }
;

bool : TOK_bool { Bool_Mk  }
;

boolean : TOK_boolean { Boolean_Mk  }
;

break : TOK_break { Break_Mk  }
;

byte : TOK_byte { Byte_Mk  }
;

case : TOK_case { Case_Mk  }
;

catch : TOK_catch { Catch_Mk  }
;

char_ : TOK_char { Char__Mk  }
;

classT : TOK_class { Class_Mk  }
;

compl : TOK_compl { Compl_Mk  }
;

const : TOK_const { Const_Mk  }
;

constCast : TOK_const_cast { ConstCast_Mk  }
;

const_Cast : TOK_const_cast { Const_Cast_Mk  }
;

constraintT : TOK_constraint { Constraint_Mk  }
;

continue : TOK_continue { Continue_Mk  }
;

data : TOK_data { Data_Mk  }
;

default : TOK_default { Default_Mk  }
;

delete : TOK_delete { Delete_Mk  }
;

deriving : TOK_deriving { Deriving_Mk  }
;

doT : TOK_do { Do_Mk  }
;

doneT : TOK_done { Done_Mk  }
;

double_ : TOK_double { Double__Mk  }
;

downtoT : TOK_downto { Downto_Mk  }
;

dynamicCast : TOK_dynamic_cast { DynamicCast_Mk  }
;

dynamic_Cast : TOK_dynamic_cast { Dynamic_Cast_Mk  }
;

elseT : TOK_else { Else_Mk  }
;

endT : TOK_end { End_Mk  }
;

enum : TOK_enum { Enum_Mk  }
;

exceptionT : TOK_exception { Exception_Mk  }
;

explicit : TOK_explicit { Explicit_Mk  }
;

extends : TOK_extends { Extends_Mk  }
;

extern : TOK_extern { Extern_Mk  }
;

externalT : TOK_external { External_Mk  }
;

falseT : TOK_false { False_Mk  }
;

family : TOK_family { Family_Mk  }
;

final : TOK_final { Final_Mk  }
;

finally : TOK_finally { Finally_Mk  }
;

float : TOK_float { Float_Mk  }
;

forT : TOK_for { For_Mk  }
;

forall : TOK_forall { Forall_Mk  }
;

foreign : TOK_foreign { Foreign_Mk  }
;

friend : TOK_friend { Friend_Mk  }
;

funT : TOK_fun { Fun_Mk  }
;

functionT : TOK_function { Function_Mk  }
;

functorT : TOK_functor { Functor_Mk  }
;

goto : TOK_goto { Goto_Mk  }
;

hiding : TOK_hiding { Hiding_Mk  }
;

ifT : TOK_if { If_Mk  }
;

implements : TOK_implements { Implements_Mk  }
;

import : TOK_import { Import_Mk  }
;

inT : TOK_in { In_Mk  }
;

includeT : TOK_include { Include_Mk  }
;

infix : TOK_infix { Infix_Mk  }
;

infixl : TOK_infixl { Infixl_Mk  }
;

infixr : TOK_infixr { Infixr_Mk  }
;

inheritT : TOK_inherit { Inherit_Mk  }
;

initializerT : TOK_initializer { Initializer_Mk  }
;

inline : TOK_inline { Inline_Mk  }
;

instance : TOK_instance { Instance_Mk  }
;

instanceof : TOK_instanceof { Instanceof_Mk  }
;

int : TOK_int { Int_Mk  }
;

interface : TOK_interface { Interface_Mk  }
;

landT : TOK_land { Land_Mk  }
;

lazyT : TOK_lazy { Lazy_Mk  }
;

letT : TOK_let { Let_Mk  }
;

listT : TOK_list { List_Mk  }
;

long : TOK_long { Long_Mk  }
;

lorT : TOK_lor { Lor_Mk  }
;

lslT : TOK_lsl { Lsl_Mk  }
;

lsrT : TOK_lsr { Lsr_Mk  }
;

lxorT : TOK_lxor { Lxor_Mk  }
;

matchT : TOK_match { Match_Mk  }
;

mdo : TOK_mdo { Mdo_Mk  }
;

methodT : TOK_method { Method_Mk  }
;

modT : TOK_mod { Mod_Mk  }
;

moduleT : TOK_module { Module_Mk  }
;

mutableT : TOK_mutable { Mutable_Mk  }
;

namespace : TOK_namespace { Namespace_Mk  }
;

native : TOK_native { Native_Mk  }
;

newT : TOK_new { New_Mk  }
;

newtype : TOK_newtype { Newtype_Mk  }
;

nonrecT : TOK_nonrec { Nonrec_Mk  }
;

not : TOK_not { Not_Mk  }
;

notEq : TOK_not_eq { NotEq_Mk  }
;

not_Eq : TOK_not_eq { Not_Eq_Mk  }
;

null : TOK_null { Null_Mk  }
;

objectT : TOK_object { Object_Mk  }
;

ofT : TOK_of { Of_Mk  }
;

openT : TOK_open { Open_Mk  }
;

operator : TOK_operator { Operator_Mk  }
;

orT : TOK_or { Or_Mk  }
;

orEq : TOK_or_eq { OrEq_Mk  }
;

or_Eq : TOK_or_eq { Or_Eq_Mk  }
;

package : TOK_package { Package_Mk  }
;

pattern : TOK_pattern { Pattern_Mk  }
;

privateT : TOK_private { Private_Mk  }
;

proc : TOK_proc { Proc_Mk  }
;

protected : TOK_protected { Protected_Mk  }
;

public : TOK_public { Public_Mk  }
;

qualified : TOK_qualified { Qualified_Mk  }
;

recT : TOK_rec { Rec_Mk  }
;

register : TOK_register { Register_Mk  }
;

reinterpretCast : TOK_reinterpret_cast { ReinterpretCast_Mk  }
;

reinterpret_Cast : TOK_reinterpret_cast { Reinterpret_Cast_Mk  }
;

return : TOK_return { Return_Mk  }
;

short : TOK_short { Short_Mk  }
;

sigT : TOK_sig { Sig_Mk  }
;

signed : TOK_signed { Signed_Mk  }
;

sizeof : TOK_sizeof { Sizeof_Mk  }
;

staticCast : TOK_static_cast { StaticCast_Mk  }
;

static_Cast : TOK_static_cast { Static_Cast_Mk  }
;

strictfp : TOK_strictfp { Strictfp_Mk  }
;

string_ : TOK_string { String__Mk  }
;

structT : TOK_struct { Struct_Mk  }
;

super : TOK_super { Super_Mk  }
;

switch : TOK_switch { Switch_Mk  }
;

synchronized : TOK_synchronized { Synchronized_Mk  }
;

template : TOK_template { Template_Mk  }
;

thenT : TOK_then { Then_Mk  }
;

this : TOK_this { This_Mk  }
;

throw : TOK_throw { Throw_Mk  }
;

throws : TOK_throws { Throws_Mk  }
;

toT : TOK_to { To_Mk  }
;

transient : TOK_transient { Transient_Mk  }
;

trueT : TOK_true { True_Mk  }
;

tryT : TOK_try { Try_Mk  }
;

typeT : TOK_type { Type_Mk  }
;

typedef : TOK_typedef { Typedef_Mk  }
;

typeid : TOK_typeid { Typeid_Mk  }
;

typename : TOK_typename { Typename_Mk  }
;

union : TOK_union { Union_Mk  }
;

unsigned : TOK_unsigned { Unsigned_Mk  }
;

using : TOK_using { Using_Mk  }
;

valT : TOK_val { Val_Mk  }
;

virtualT : TOK_virtual { Virtual_Mk  }
;

void : TOK_void { Void_Mk  }
;

volatile : TOK_volatile { Volatile_Mk  }
;

wcharT : TOK_wchar_t { WcharT_Mk  }
;

wchar_T : TOK_wchar_t { Wchar_T_Mk  }
;

whenT : TOK_when { When_Mk  }
;

where : TOK_where { Where_Mk  }
;

whileT : TOK_while { While_Mk  }
;

withT : TOK_with { With_Mk  }
;

xor : TOK_xor { Xor_Mk  }
;

xorEq : TOK_xor_eq { XorEq_Mk  }
;

xor_Eq : TOK_xor_eq { Xor_Eq_Mk  }
;
